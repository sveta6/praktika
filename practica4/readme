Часть 1.

Задание 1.
Создать класс, реализующий интерфейс Runnable. Переопределить run() метод. Создать цикл for. В цикле распечатываем значения от 0 до 100 делящиеся на 10 без остатка. Используйте статический метод Thread.sleep() чтобы сделать паузу. Создать три потока, выполняющих задачу распечатки значений.

Задание 2.
Необходимо создать три потока которые изменяют один и тот же объект. Каждый поток должен вывести на экран одну букву 100 раз, и затем увеличить значение символа на 1.
a) Создать класс расширяющий Thread. 
б) Переопределить метод run(), здесь будет находится синхронизированный блок кода. 
в) Для того чтобы три объекта-потока имели доступ к одному объекту, создаем конструктор принимающий на вход StringBuilder объект. 
г) Синхронизированный блок кода будет получать монитор на объект StringBuilder из пункта в). 
д) Внутри синхронизированного блока кода выведите StringBuilder на экран 100 раз, а потом увеличьте значение символа на 1. 
е) В методе main() создайте один объект класса StringBuilder, используя символ ‘a’. Затем создайте три экземпляра объекта этого класса и запустите потоки. 

Задание 3.
Создать два класса нитей WriteThread и ReadThread (наследуют от класса Thread), взаимодействующих с помощью промежуточного объекта типа Vector. 
Первая нить последовательно заполняет вектор (изначально он заполнен нулями) произвольными различными величинами (например, случайными), отличными от нуля. Каждый раз, когда она помещает значение в вектор, она выводит на экран сообщение вида “Write: 100.5 to position 3”. По достижении конца вектора нить заканчивает свое выполнение. 
Вторая нить последовательно считывает значения из вектора и выводит их на экран сообщениями вида “Read: 100.5 from position 3”. По достижении конца вектора нить заканчивает свое выполнение. 
В методе main() следует создать 3 участвующих в процессе объекта и запустить нити на выполнение. Запустите программу несколько раз. Попробуйте варьировать приоритеты нитей.

Задание 4.
Сортировка Шелла. Реализуйте алгоритм сортировки Шелла используя несколько потоков. Программа должна состоять из управляющего и нескольких рабочих потоков. 
Рабочие потоки обращаются к управляющему за очередным заданием – отсортировать часть элементов массива с заданным шагом и начиная с заданного элемента. 
Число рабочих потоков вводится пользователем во время выполнения программы.

Часть 2.

Напишите на языке Java программу моделирования процессов с использованием потоков.
 Для всех заданий требуется создать три класса:
CPUQueue, где будет описываться очередь;
CPUProcess, который моделирует поток процессов;
CPU, который моделирует поток обслуживания (исполнения) процесса на центральном процессоре.
 Параметры очереди моделируются с помощью алгоритмов вставки и вытягивания процесса с очереди. Параметром процесса является интервал времени между двумя последовательными генерациями процессов. Параметром процессора является время обслуживания процесса.
Случайное время для интервалов между моментами генерации процессов и для времени обслуживания, задаётся методом Math.random();
Необходимо определить верхнюю и нижнюю границы случайных значений (это можно сделать путём арифметических операций с результатами метода). 
Начальные данные для моделирования - количество процессов, которые должны быть сгенерированы каждым потоком процессов, а также нижние и верхние границы для потоков.

Задание 1.
В одном МФЦ работают три окна (“центральные процессоры”), которые обслуживают три категории (“потока”) граждан (“процессы”): молодые, пожилые и бизнесмены. Окна работают без очередей. 
Первое окно принимает любые категории граждан, второе - только вторую категорию, а третье - только третью. 
Если гражданин не может получить услугу из-за занятости окна, то он разгневанно уходит. Определить процент ушедших клиентов из каждой категории.
 
Задание 2.
В поликлинике все пациенты принимаются двумя кабинетами (терапевт и МРТ) с единой (одной) очередью. 
Когда пациент выходит из очереди, он сначала принимается терапевтом. Как только осмотр заканчивается, пациент отправляется в кабинет МРТ, а к терапевту поступает следующий пациент, если очередь не пустая. 
Пациент у терапевта ждёт окончания обследования предыдущего пациента на МРТ, прежде чем выйти.
Определить максимальную длину очереди из пациентов.
